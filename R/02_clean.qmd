---
title: "02_clean.qmd"
format: html
editor: visual
author: "Anna Boateng: s175562, Marlies Goedknegt: s220675, Anne Gjelstrup: s194530, Katja Jagd: s185395, Olivia Ronnenberg: s183359"
---

## Part 02: clean

### Accessing relevant functions

In order to perform the required cleaning steps on the acquired data frames, an in order to avoid repetition of the code, functions were created. These can be found in the file mentioned below.

```{r}
#| label: use functions from file

source("99_proj_func.R")
```


#### Import the required packages

```{r}
#| label: load packages
#| message: false

library("tidyverse")
library("patchwork")

```

### Read in the loaded data files

```{r}
#| label: load in data

coexpression_clean <- read_tsv("../data/01_coexpression_load.tsv.gz",
                               show_col_types = FALSE)

regulators_before_clean <- read_tsv("../data/01_regulators_before_load.tsv.gz",
                                    show_col_types = FALSE, skip = 1)

regulators_after_clean <- read_tsv("../data/01_regulators_after_load.tsv.gz",
                                   show_col_types = FALSE, skip = 1)
```

### Cleaning of co-expression data

As stated before, data table 1 contains data on 20 co-expression modules. In the code below, the table is tidied by having each gene "assigned" to the relevant module one by one. This is done by pivoting the dataframe into a long format.

```{r}
#| label: Cleaning data table 1

coexpression_clean <- coexpression_clean |>
  pivot_longer(cols = everything(),
               names_to = "modules",
               values_to = "gene") 
```

### Cleaning the two data frames describing upstream regulators before and after treatment

This is where the function file, loaded previously, will be used. Each code block represents the use of a single function, described above each respective code block.

The following code block utulizes a function that fixes renames headers, and ensures all floats in the data frame is interpreted as numeric values. It also selects relevant columns for further analysis.

```{r}
#| label: Fixing names and values
regulators_before_clean <- fix_headers_and_values(regulators_before_clean,
                                              " before") 
regulators_after_clean <- fix_headers_and_values(regulators_after_clean,
                                              " after") 

```

The chuck below can be deleted if we dont want the volcano plots as discused friday 24th Nov.

```{r}
expr_data_before_unfiltered <- regulators_before_clean |> 
  select(-contains("target"), -contains("molecule"))

expr_data_after_unfiltered <- regulators_after_clean |> 
  select(-contains("target"), -contains("molecule"))
```

The following code utilizes a function which filters significant p-values (over 0.05) and expression level between -0.15 and 0.15.

```{r}
#| label: Select significant observations
regulators_before_clean <- filter_significant_observations(regulators_before_clean,
                                                           p_value_of_overlap_before,
                                                           expr_log_ratio_before)

regulators_after_clean <- filter_significant_observations(regulators_after_clean,
                                                           p_value_of_overlap_after,
                                                           expr_log_ratio_after)
```

The functions below collect, and join, selected parts of two data frames (before and after treatment). This enables two new data frames to be created: one with target molecule data, and one with expression data. Each of these data frames contain data from before and after treatment.

```{r}

#| label: Joining and splitting the two dataframes 

target_data <- all_target_data(regulators_before_clean, regulators_after_clean)
expr_data <- all_expression_data(regulators_before_clean, regulators_after_clean)

```

Adding the number of target molecules before and after treatment as a column. This augmentation to the target_data is performed before a tidy dataframe has been obtained. This is done as the count of several values in a cell is easily intepreted at the number of commas + 1. This way we do not have to iterate over several columns to count the number of values associated with similar variables.

```{r}
target_data <- target_data |>
  mutate(n_before = str_count(target_molecules_in_dataset_before,
                                pattern = ",") + 1,
         n_after = str_count(target_molecules_in_dataset_after,
                                pattern = ",") + 1) |> 
  relocate(c(n_before, n_after),
           .after = upstream_regulator)
  
```
